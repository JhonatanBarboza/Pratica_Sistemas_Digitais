```VHDL
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_ARITH.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;

-- Entidade principal do Processador
entity Processor is
    Port (
        clk      : in  STD_LOGIC;
        reset    : in  STD_LOGIC;
        switches : in  STD_LOGIC_VECTOR(7 downto 0);  -- Entrada (chaves do FPGA)
        leds     : out STD_LOGIC_VECTOR(7 downto 0)   -- Saída (LEDs do FPGA)
    );
end Processor;

architecture Behavioral of Processor is
    -- Barramentos principais
    signal addr_bus    : STD_LOGIC_VECTOR(7 downto 0); -- Barramento de Endereço
    signal data_bus    : STD_LOGIC_VECTOR(7 downto 0); -- Barramento de Dados
    signal control_bus : STD_LOGIC_VECTOR(3 downto 0); -- Barramento de Controle

    -- Registradores e sinais internos da CPU
    signal A, B, R, PC : STD_LOGIC_VECTOR(7 downto 0); -- Registradores principais
    signal ALUop       : STD_LOGIC_VECTOR(2 downto 0); -- Operação da ALU
    signal ZeroFlag    : STD_LOGIC;                    -- Flag Zero da ALU
begin

    -- Unidade de Controle
    ControlUnit: process(control_bus)
    begin
        case control_bus is
            when "0000" => control_bus <= "1000"; -- Exemplo: LOAD
            when "0001" => control_bus <= "0100"; -- Exemplo: STORE
            when "0010" => control_bus <= "0010"; -- Exemplo: ADD
            when "0011" => control_bus <= "0001"; -- Exemplo: SUB
            when others => control_bus <= (others => '0');
        end case;
    end process;

    -- ALU (Unidade Lógica e Aritmética)
    ALU: process(A, B, ALUop)
    begin
        case ALUop is
            when "000" => R <= A + B;                  -- ADD
            when "001" => R <= A - B;                  -- SUB
            when "010" => R <= A and B;                -- AND
            when "011" => R <= A or B;                 -- OR
            when "100" => R <= not A;                  -- NOT
            when others => R <= (others => '0');
        end case;

        -- Atualiza a flag Zero se o resultado for zero
        ZeroFlag <= '1' when R = "00000000" else '0';
    end process;

    -- CPU principal
    CPU: process(clk, reset)
    begin
        if reset = '1' then
            PC <= (others => '0');
            A <= (others => '0');
            B <= (others => '0');
            R <= (others => '0');
        elsif rising_edge(clk) then
            -- Controle de fluxo e execução das instruções
            if control_bus(3) = '1' then  -- LOAD
                A <= data_bus;
            elsif control_bus(2) = '1' then  -- STORE
                addr_bus <= PC;
                data_bus <= A;
            end if;
        end if;
    end process;

    -- Memória Simples
    Memory: process(clk)
        type memory_array is array (0 to 255) of STD_LOGIC_VECTOR(7 downto 0);
        signal memory : memory_array := (others => (others => '0'));
    begin
        if control_bus(3) = '1' then  -- Leitura de Memória
            data_bus <= memory(to_integer(unsigned(addr_bus)));
        elsif control_bus(2) = '1' then  -- Escrita de Memória
            memory(to_integer(unsigned(addr_bus))) <= data_bus;
        end if;
    end process;

end Behavioral;
```
